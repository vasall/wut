#include "source/core/inc/predefined.h"

/*
 * -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 *
 *		DEFAULT SCROLLBAR SHADER
 *
 * -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
*/

char *_wut_prScrollbarVtxShd = 
"#version 420 core\n"
"layout(location=0) in vec3 in_position;"
"layout(location=1) in ivec3 in_index;"
"layout(location=2) in int in_type;"
""
""
"uniform ivec2   u_frame;"
"uniform ivec4   u_rect[200];"
"uniform vec4    u_color[200];"
"uniform int     u_width[200];"
"uniform ivec2	 u_scroll[200];"
"uniform ivec4	 u_limit[200];"
""
"flat out vec2   fs_frame;"
"flat out int    fs_type;"
"out vec4        fs_color;"
"flat out int    fs_width;"
"flat out ivec2  fs_scroll;"
"flat out vec4   fs_sides;"
"flat out vec4	 fs_limits;"
"flat out vec2   fs_cpoints[4];"
""
"void main() {"
"	vec2 lframe = u_frame * 0.5;"
"	ivec4 lrect = u_rect[in_index.x];"
"	ivec4 llimits = ivec4(0, 0, u_frame.x, u_frame.y);"

"	if(in_index.y != -1) {"
"		llimits = u_limit[in_index.y];"
"	}"
""
"	fs_frame = u_frame;"
"	fs_type = in_type;"
"	fs_sides = vec4(lrect.y, lrect.x+lrect.z, lrect.y+lrect.w, lrect.x);"
"	fs_limits = vec4(llimits.y, llimits.x+llimits.z, llimits.y+llimits.w, llimits.x);"
""   
"	fs_color = u_color[in_index.z];"
"	fs_width = u_width[in_index.z];"
"	fs_scroll = u_scroll[in_index.z];"
""
"	switch(in_type) {"
"		case 2:"	/* vertical scrollbar */
"			fs_cpoints = vec2[4](vec2(0,0),vec2(0,0),vec2(0,0),vec2(0,0));"
"			break;"
"		case 3:"	/* horizontal scrollbar */
"			fs_cpoints = vec2[4](vec2(0,0),vec2(0,0),vec2(0,0),vec2(0,0));"
"			break;"
"		default:"
"			fs_cpoints = vec2[4](vec2(0,0),vec2(0,0),vec2(0,0),vec2(0,0));"
"			break;"
"	}"
""
"	gl_Position = vec4((in_position.x - lframe.x) / lframe.x, (lframe.y - in_position.y) / lframe.y, 1, in_position.z);"
"}";

char *_wut_prScrollbarFragShd = 
"#version 420 core\n"
""
"flat in vec2    fs_frame;"
"flat in int     fs_type;"
"in vec4         fs_color;"
"flat in int     fs_width;"
"flat in ivec2   fs_scroll;"
"flat in vec4    fs_sides;"
"flat in vec4	 fs_limits;"
"flat in vec2    fs_cpoints[4];"
""
"out vec4 out_color;"
""
"void main() {"
"	int corner = -1;"
"	vec2 loc = vec2(gl_FragCoord.x, fs_frame.y - gl_FragCoord.y);"
"	float alpha = 1.0;"
"	vec4 color;"
"	float dist;"
""
"	int scroll_thumbsize = fs_width - 2;"
"	int scroll_end_padding = 1;"
"	int scroll_side_padding = (fs_width - scroll_thumbsize) / 2;"
""
"	if(loc.y < fs_limits[0] || loc.x > fs_limits[1] || loc.y > fs_limits[2] || loc.x < fs_limits[3]) {"
"		discard;"
"	}"
"	else {"
"		switch(fs_type) {"
"			case 2:"	/* vertical scrollbar */
"				if(loc.y > fs_sides[0] + scroll_end_padding + fs_scroll[0] && loc.x < fs_sides[1] - scroll_side_padding && loc.y < fs_sides[0] + scroll_end_padding + fs_scroll[0] + fs_scroll[1] && loc.x > fs_sides[3] + scroll_side_padding) {"
"					out_color = vec4(0.1, 0.1, 0.1, 1);"
"				}"
"				else {"
"					out_color = vec4(1, 1, 0, 0);"
"				}"
"				break;"
"			case 3:"	/* horizontal scrollbar */
"				if(loc.y > fs_sides[0] + scroll_side_padding && loc.x < fs_sides[3] + scroll_end_padding + fs_scroll[0] + fs_scroll[1] && loc.y < fs_sides[2] - scroll_side_padding && loc.x > fs_sides[3] + scroll_end_padding + fs_scroll[0]) {"
"					out_color = vec4(0.1, 0.1, 0.1, 1);"
"				}"
"				else {"
"					out_color = vec4(1, 1, 0, 0);"
"				}"
"				break;"
"			default:"
"				out_color = vec4(1, 0, 0, 1);"
"				break;"
"		}"
"	}"
"};";


/*
 * -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 *
 *		DEFAULT BLOCK SHADER
 *
 * -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
*/

char *_wut_prBlockVtxShd = 
"#version 420 core\n"
"layout(location=0) in vec3 in_position;"
"layout(location=1) in ivec3 in_index;"
"layout(location=2) in int in_type;"
""
""
"uniform ivec2   u_frame;"
"uniform ivec4   u_rect[200];"
"uniform vec4    u_color[200];"
"uniform ivec4   u_radius[200];"
"uniform int     u_bwidth[200];"
"uniform vec4    u_bcolor[200];"
"uniform ivec2	 u_scroll[200];"
"uniform ivec4	 u_limit[200];"
""
"flat out vec2   fs_frame;"
"flat out int    fs_type;"
"out vec4        fs_color;"
"flat out vec4   fs_sides;"
"flat out vec4	 fs_limits;"
"flat out vec2   fs_cpoints[4];"
"flat out ivec4  fs_radius;"
"flat out int    fs_bwidth;"
"flat out vec4   fs_bcolor;"
"flat out ivec2  fs_scroll;"
""
"void main() {"
"	vec2 lframe = u_frame * 0.5;"
"	ivec4 lrect = u_rect[in_index.x];"
"	ivec4 llimits = ivec4(0, 0, u_frame.x, u_frame.y);"

"	if(in_index.y != -1) {"
"		llimits = u_limit[in_index.y];"
"	}"
""
"	fs_frame = u_frame;"
"	fs_type = in_type;"
"	fs_sides = vec4(lrect.y, lrect.x+lrect.z, lrect.y+lrect.w, lrect.x);"
"	fs_limits = vec4(llimits.y, llimits.x+llimits.z, llimits.y+llimits.w, llimits.x);"
""
"	switch(in_type) {"
"		case 1:"	/* default block */
"			ivec4 lradius = u_radius[in_index.z];"
"			fs_color = u_color[in_index.z];"
"			fs_cpoints = vec2[4]("
"				vec2(lrect.x + lradius[0], lrect.y + lradius[0]),"
"				vec2(lrect.x + lrect.z - lradius[1], lrect.y + lradius[1]),"
"				vec2(lrect.x + lrect.z - lradius[2], lrect.y + lrect.w - lradius[2]),"
"				vec2(lrect.x + lradius[3], lrect.y + lrect.w - lradius[3])"
"			);"
"			fs_radius = lradius;"
"			fs_bwidth = u_bwidth[in_index.z];"
"			fs_bcolor = u_bcolor[in_index.z];"
"			fs_scroll = ivec2(0, 0);"
"			break;"
"		default:"
"			fs_color = vec4(0, 0, 0, 1);"
"			fs_cpoints = vec2[4](vec2(0,0),vec2(0,0),vec2(0,0),vec2(0,0));"
"			fs_radius = ivec4(0, 0, 0, 0);"
"			fs_bwidth = 0;"
"			fs_bcolor = vec4(0.0, 0, 0, 1.0);"
"			fs_scroll = ivec2(0, 0);"
"			break;"
"	}"
""
"	gl_Position = vec4((in_position.x - lframe.x) / lframe.x, (lframe.y - in_position.y) / lframe.y, 1, in_position.z);"
"}";

char *_wut_prBlockFragShd = 
"#version 420 core\n"
""
"flat in vec2    fs_frame;"
"flat in int     fs_type;"
"in vec4         fs_color;"
"flat in vec4    fs_sides;"
"flat in vec4	 fs_limits;"
"flat in vec2    fs_cpoints[4];"
"flat in ivec4   fs_radius;"
"flat in int     fs_bwidth;"
"flat in vec4    fs_bcolor;"
"flat in ivec2   fs_scroll;"
""
"out vec4 out_color;"
""
"void main() {"
"	int corner = -1;"
"	vec2 loc = vec2(gl_FragCoord.x, fs_frame.y - gl_FragCoord.y);"
"	float alpha = 1.0;"
"	vec4 color;"
"	float dist;"
""
"	int scrollbar_width = 2;"
"	int scroll_thumbsize = 8;"
"	int scroll_end_padding = 1;"
"	int scroll_side_padding = (scrollbar_width - scroll_thumbsize) / 2;"
""
"	if(loc.y < fs_limits[0] || loc.x > fs_limits[1] || loc.y > fs_limits[2] || loc.x < fs_limits[3]) {"
"		discard;"
"	}"
"	else {"
"		switch(fs_type) {"
"			case 1:"    /* default block */
"				if(loc.x <= fs_cpoints[0].x && loc.y <= fs_cpoints[0].y) corner = 0;"
"				else if(loc.x >= fs_cpoints[1].x && loc.y <= fs_cpoints[1].y) corner = 1;"
"				else if(loc.x >= fs_cpoints[2].x && loc.y >= fs_cpoints[2].y) corner = 2;"
"				else if(loc.x <= fs_cpoints[3].x && loc.y >= fs_cpoints[3].y) corner = 3;"
""
"				if(corner < 0) {"
"					if(loc.y <= fs_sides[0] + fs_bwidth || loc.x >= fs_sides[1] - fs_bwidth || loc.y >= fs_sides[2] - fs_bwidth || loc.x <= fs_sides[3] + fs_bwidth) {"
"						color = fs_bcolor;"
"					}"
"					else {"
"						color = fs_color;"
"					}"
"				}"
"				else {"
"					dist = distance(loc, fs_cpoints[corner]);"
"					if(dist >= fs_radius[corner]) alpha = 0;"
"					else if(dist >= (fs_radius[corner] - fs_bwidth)) color = fs_bcolor;"
"					else color = fs_color;"
"				}"
"				out_color = vec4(color.xyz, color.w * alpha);"
"				break;"
"			default:"
"				out_color = vec4(1, 0, 0, 1);"
"				break;"
"		}"
"	}"
"};";



/*
 * -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 *
 *		DEFAULT TEXTURE SHADER
 *
 * -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
*/

char *_wut_prTextureVtxShd = 
"#version 420 core\n"
"layout(location=0) in vec3 in_position;"
"layout(location=1) in vec2 in_uv;"
"layout(location=2) in ivec3 in_index;"
""
""
"uniform ivec2   u_frame;"
"uniform ivec4   u_rect[200];"
"uniform ivec4   u_radius[200];"
"uniform ivec4	 u_limit[200];"
""
"flat out vec2   fs_frame;"
"flat out vec4   fs_sides;"
"flat out vec4	 fs_limits;"
"flat out vec2   fs_cpoints[4];"
"flat out ivec4  fs_radius;"
"out vec2 		 fs_uv;"
""
"void main() {"
"	vec2 lframe = u_frame * 0.5;"
"	ivec4 lrect = u_rect[in_index.x];"
"	ivec4 llimits = ivec4(0, 0, u_frame.x, u_frame.y);"

"	if(in_index.y != -1) {"
"		llimits = u_limit[in_index.y];"
"	}"
""
"	fs_frame = u_frame;"
"	fs_sides = vec4(lrect.y, lrect.x+lrect.z, lrect.y+lrect.w, lrect.x);"
"	fs_limits = vec4(llimits.y, llimits.x+llimits.z, llimits.y+llimits.w, llimits.x);"
""
"	ivec4 lradius = u_radius[in_index.z];"
"	fs_cpoints = vec2[4]("
"		vec2(lrect.x + lradius[0], lrect.y + lradius[0]),"
"		vec2(lrect.x + lrect.z - lradius[1], lrect.y + lradius[1]),"
"		vec2(lrect.x + lrect.z - lradius[2], lrect.y + lrect.w - lradius[2]),"
"		vec2(lrect.x + lradius[3], lrect.y + lrect.w - lradius[3])"
"	);"
"	fs_radius = lradius;"
"	fs_uv = in_uv;"
""
"	gl_Position = vec4((in_position.x - lframe.x) / lframe.x, (lframe.y - in_position.y) / lframe.y, 1, in_position.z);"
"}";

char *_wut_prTextureFragShd = 
"#version 420 core\n"
""
"flat in vec2   fs_frame;"
"flat in vec4   fs_sides;"
"flat in vec4	fs_limits;"
"flat in vec2   fs_cpoints[4];"
"flat in ivec4  fs_radius;"
"in vec2 		fs_uv;"
""
"uniform sampler2D ourTexture;"
""
"out vec4 out_color;"
""
"void main() {"
"	int corner = -1;"
"	vec2 loc = vec2(gl_FragCoord.x, fs_frame.y - gl_FragCoord.y);"
"	float alpha = 1.0;"
"	vec4 color;"
"	float dist;"
""
"	if(loc.y < fs_limits[0] || loc.x > fs_limits[1] || loc.y > fs_limits[2] || loc.x < fs_limits[3]) {"
"		discard;"
"	}"
"	else {"
"		if(loc.x <= fs_cpoints[0].x && loc.y <= fs_cpoints[0].y) corner = 0;"
"			else if(loc.x >= fs_cpoints[1].x && loc.y <= fs_cpoints[1].y) corner = 1;"
"			else if(loc.x >= fs_cpoints[2].x && loc.y >= fs_cpoints[2].y) corner = 2;"
"			else if(loc.x <= fs_cpoints[3].x && loc.y >= fs_cpoints[3].y) corner = 3;"
""
"			if(corner < 0) {"
"				color = texture(ourTexture, fs_uv);"
"			}"
"			else {"
"				dist = distance(loc, fs_cpoints[corner]);"
"				if(dist >= fs_radius[corner]) alpha = 0;"
"				else color = texture(ourTexture, fs_uv);"
"			}"
"			out_color = vec4(color.xyz, color.w * alpha);"
"	}"
"};";


/*
 * -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 *
 *		DEFAULT TEXT SHADER
 *
 * -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
*/


char *_wut_prTextVtxShd =
"#version 420 core\n"
"layout(location=0) in vec3 in_pos;"
"layout(location=1) in vec2 in_uv;"
"layout(location=2) in int  in_index;"
""
"uniform ivec2      u_frame;"
"uniform ivec4      u_limit[200];"
""
"flat out vec2   fs_frame;"
"out vec2        fs_uv;"
"out vec3        fs_color;"
"flat out vec4   fs_limits;"
""
"void main() {"
"	vec2 lframe = u_frame * 0.5;"
"    ivec4 llimits = ivec4(0, 0, u_frame.x, u_frame.y);"
""
"	if(in_index != -1) {"
"        llimits = u_limit[in_index];"
"	}"
""
"	fs_frame = u_frame;"
"	gl_Position = vec4((in_pos.x - lframe.x) / lframe.x, (lframe.y - in_pos.y) / lframe.y, 1, 1);"
"	fs_limits = vec4(llimits.y, llimits.x+llimits.z, llimits.y+llimits.w, llimits.x);"
""
"    fs_uv      = vec2(in_uv.x, in_uv.y);"
"	fs_color   = vec3(1.0, 1.0, 1.0);"
"}";


char *_wut_prTextFragShd =
"#version 420 core\n"
""
"precision mediump float;"
""
"flat in vec2 fs_frame;"
"in vec2 fs_uv;"
"in vec3 fs_color;"
"flat in vec4 fs_limits;"
""
"uniform sampler2D ourTexture;"
""
"out vec4 color;"
""
"void main() {"
"	vec2 loc = vec2(gl_FragCoord.x, fs_frame.y - gl_FragCoord.y);"
"    float signed_distance = texture( ourTexture, fs_uv ).r;"
""
"	if(1>2) {"
"		discard;"
"	}"
"   else {"
"        if(signed_distance >= 0.492) {"
"            color.rgb = vec3(0, 0, 0);"
"            color.a   = 1.0;"
"        }"
"        else {"
"            color.rgb = vec3(1, 1, 1);"
"            color.a   = 1.0;"
"        }"
"    }"
"}";
